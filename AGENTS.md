# Инструкция по разработке $eve

1. Все интерфейсы мы строим на базе сущность eve_surface, потому что она заключает в себе правила дизайна. Не используем mol_view.
2. Мы строим отдельную библиотеку компонентов. Минимизируем прямое использование компонентов mol и делаем наследники с перебиванием цветов.


# Инструкция по работе с \$mol и CRUS-DB

## 1. Запуск проекта (\$mol + CRUS-DB)

1. Установите Node.js (версия LTS) и git.
2. Клонируйте стартовый репозиторий MAM:

   ```bash
   git clone https://github.com/hyoo-ru/mam.git ./mam && cd mam
   npm install && npm start
   ```

   Это создаст локальный dev-сервер. После сборки откроется приложение по умолчанию (например, [http://localhost:9080/my/survey/app/-/test.html)\:contentReference\[oaicite:0\]{index=0}\:contentReference\[oaicite:1\]{index=1}](http://localhost:9080/my/survey/app/-/test.html%29:contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}). Сборщик MAM отслеживает файлы, автоматически подтягивает модули и пересобирает бандлы при изменении кода.
3. **Структура проекта:** MAM-окружение строит проект по папочкам-модулям. В каталоге `mam` создайте собственный неймспейс и приложение, например:

   ```
   cd mam
   mkdir my && cd my
   mkdir survey && cd survey
   mkdir app person meet
   ```

   В каждой папке (`app`, `person`, `meet` и т.д.) размещайте файлы вашего модуля (код, шаблоны, стили). MAM автоматически сгенерирует `package.json` и другие настройки, если они не указаны вручную.
4. **Точка входа:** В подпапке с UI (например, `app`) создайте `index.html` – обычный HTML с корневым элементом для монтирования. В `index.html` нужно подключить модуль вашего приложения (сборщик сам встраивает скрипты). *Важно:* файл `index.html` нельзя класть в корень неймспейса, только внутрь модуля (например, `my/survey/app/index.html`).
5. **Подключение CRUS-DB:** В коде используйте классы CRUS как глобальную базу. Например, указывайте в макете приложения `$mol_book2_catalog` параметр `realm $hyoo_crus_realm` – это встроенный репозиторий CRUS. В TypeScript-коде для получения данных используйте `$hyoo_crus_ref`, `$hyoo_crus_glob`, методы `Node()`, `home().hall_by(...)` и др. (см. пример в п.3). CRUS-DB работает «локально»: все изменения сначала сохраняются на клиенте, а затем синхронизируются с другими пирами без конфликтов.
6. **Запуск dev-сервера:** После создания структуры запустите сервер командой `npm start`. Доступ к приложению будет по адресу вида `http://localhost:9080/<ваш-неймспейс>/<модуль>/-/test.html`. По мере разработки MAM автоматически выполняет компиляцию и рефреш, следя за всеми зависимостями.

## 2. Подключение внешних NPM-пакетов

В MAM/\$mol можно подключать NPM-библиотеки двумя основными способами:

* **Через `require`:** Просто используйте `const lib = require('название-пакета') as typeof import('название-пакета')`. При сборке MAM попытaется включить его в бандл, автоматически подтянет код и типы. Например:

  ```ts
  @ $mol_mem
  todayDate() {
      const moment = require('moment') as typeof import('moment');
      return moment().format('DD.MM.YYYY');
  }
  ```

  Сборщик сам установит `moment` из NPM при необходимости. Однако не все пакеты готовы к прямой компиляции MAM. Если пакет сложный, может потребоваться предсборка его в отдельный бандл (например, через Rollup/Webpack) и последующий импорт.

* **Динамическая загрузка:** Для непредусмотренных пакетов можно подгружать их из внешних URL. Например, `$mol_import.script(url)` загружает сторонний скрипт, `$mol_import.module(url)` – ESM-модуль. Пример:

  ```ts
  const { equals } = $mol_import.module('https://esm.sh/ramda');
  ```

  Это позволит избежать проблем с бандлингом.

После установки пакета вы можете пользоваться его API как обычно. При использовании статических методов обращайте внимание на типы: рекомендуется писать `as typeof import('package')` для корректной поддержки TypeScript.

## 3. Архитектура проекта и примеры кода (survey.hyoo.ru)

Проект *survey.hyoo.ru* демонстрирует микромодульную архитектуру \$mol+CRUS. Основные компоненты:

* **Модели данных (CRUS-DB):** Данные проекта лежат в графовой схеме CRUS. В коде она формализована через модели. Например, в `person.ts` описывается модель пользователя:

  ```ts
  class $my_survey_person extends Dict.with({
      Meets: List_ref( ()=> $my_survey_meet ),
  }) {}
  ```

  А в `meet.ts` – модель встречи с полями `Title`, `Owner`, `Opinions`:

  ```ts
  class $my_survey_meet extends Dict.with({
      Title: Str,
      Owner: Ref( ()=> $my_survey_person ),
      Opinions: Ref( ()=> $my_survey_opinions ),
  }) {}
  class $my_survey_opinions extends Dict_to(
      Ref( ()=> $my_survey_opinion )
  ) {}
  class $hyoo_survey_opinion extends Dict.with({
      Descr: Text,
  }) {}
  ```

  Эти классы (расширяющие `Dict`) задают структуру данных. Важное отличие: `Str` – атомарная строка (сохраняет только последнее значение), а `Text` – мерджимая строка (CRDT), которая при вводе отправляет только дельты изменений.

* **Логика (методы моделей):** Модели содержат методы для удобной работы с данными. Например, метод создания встречи у персоны:

  ```ts
  class $my_survey_person extends Dict.with({ Meets: List_ref( ()=> $my_survey_meet ) }) {
    @act meet_make() {
        const meet = this.Meets(null)!.remote_make({ '': Rank.get })!;
        meet.Owner(null)!.val(this.land().auth().lord());
        return meet;
    }
  }
  ```

  Здесь `remote_make` создает новую запись встречи с правом чтения для всех (`Rank.get`), а затем устанавливается поле `Owner` текущим пользователем. Похожим образом определен метод получения текущего мнения на встрече:

  ```ts
  export class $my_survey_meet extends Dict.with({ ... }) {
    @mem opinion_my() {
        const my_auth = this.land().auth();
        const owner_key = this.Owner()?.remote()?.land().key();
        if( !owner_key ) return null;
        const opinions = this.Opinions(null)?.remote_ensure({ '': Rank.add });
        const opinion = opinions?.key(my_auth.peer(), null)?.remote_ensure({
            [owner_key.toString()]: Rank.get,
            [my_auth.public().toString()]: Rank.law,
        }) ?? null;
        return opinion;
    }
  }
  ```

  Этот код обеспечивает конфиденциальность: создаёт/находит объект мнения текущего пользователя с нужными правами доступа. Также есть методы для получения списка ID отзывов и конкретного отзыва по ID:

  ```ts
  @mem responder_refs() {
      return this.Opinions()?.remote()?.keys()
             .map($hyoo_crus_vary_cast_ref)
             .filter($mol_guard_defined) ?? [];
  }
  @mems opinion( responder: $hyoo_crus_ref ) {
      const options = this.Opinions()?.remote();
      return options?.key(responder.description!)?.remote() ?? null;
  }
  ```

  Всё это – реактивные свойства, помеченные `@mem`/`@mems` или `@act`, автоматически обновляются при изменении данных.

* **UI и навигация:** Для фронтенда используются компоненты `$mol_view` и готовые конструкторы. В `app.view.tree ` задаётся главный компонент-книжка:

  ```view.tree
  $my_survey_app $mol_book2_catalog
      realm $hyoo_crus_realm
      param \meet
      Spread* <= Meet* $my_survey_meet_form
          meet <= meet* $my_survey_meet
      Placeholder $mol_page
          title @\ Graceful Feedback
  ```

  Здесь `realm $hyoo_crus_realm` задаёт CRUS-репозиторий как источник данных, `param \meet` – имя параметра в URL для выбранной встречи. `Spread` определяет страницу-развёртку `meet_form`, куда передаётся модель встречи (`meet <= meet*` связывает её с параметром).

  Далее в том же `app.ts` привязываются данные к интерфейсу через свойства:

  ```ts
  @mem profile() {
      return this.realm().home().hall_by($my_survey_person, {});
  }
  @mem spread_ids() {
      return this.profile()?.Meets()?.remote_list()
             .map(meet => meet.ref().description!) ?? [];
  }
  @mems meet(id: string) {
      const ref = $hyoo_crus_ref(id);
      return this.realm().Node(ref, $my_survey_meet);
  }
  ```

  Здесь `profile()` берёт или создаёт профиль текущего пользователя (экземпляр `$my_survey_person`) – это владелец списка встреч. `spread_ids()` возвращает массив строк-идентификаторов встреч для меню, а `meet(id)` достаёт из базы конкретную встречу по ID (через `Node`). Всё это – реактивные mem-функции.

* **Стилизация:** Стили задаются декларативно через `$mol_style_define`. Пример – стили для формы встречи в `meet_form.ts`:

  ```ts
  $mol_style_define($my_survey_meet_form, {
    flex: { basis: `40rem` },
    margin: [0, 'auto'],
    Opinion: {
      margin: $mol_gap.block,
      background: { color: $mol_theme.card },
    },
  });
  ```

  Это добавляет к компоненту и его подкомпонентам (`Opinion`) указанные стили. Благодаря статической типизации стилей `$mol`, компилятор проверит, что `Opinion` действительно есть в `meet_form`. Такая система позволяет строго типизировать CSS-правила и иерархию компонентов.

Таким образом, архитектура приложения демонстрирует *микромодульность* (\$mol view-компоненты + стили + логику можно разрабатывать отдельно), *реактивность* (вся логика при записи/чтении из CRUS-DB автоматически обновляет UI) и *декларативность* (конфигурация `$mol_book2` и `$mol_style_define` оперируют понятными свойствами, без явного DOM-манипулирования).

## 4. Ключевые отличия \$mol и CRUS-DB от других технологий

* **\$mol vs React/Angular:** `$mol` – это **высокоуровневый** фреймворк, тогда как React – библиотека, а Angular – «низкоуровневый фреймворк». В простом приложении \$mol добавляет примерно в 3 раза меньше кода на страницу, чем React (с учётом Redux, Router и т.д.). Основные принципы \$mol – *ленивость и реактивность на всех уровнях*: любые свойства компонентов `@mem` вычисляются только при необходимости и кэшируются, нет ручных подписок/отписок. По сравнению с React/Angular здесь нет виртуального DOM и пропсов – вместо этого всё строится на автоматическом отслеживании зависимостей между свойствами моделей и представлений.

  В \$mol крайне упрощённа работа со сторонними компонентами и кодом: сборщик сам «берёт» из npm нужные модули при первом обращении, а ненужные модули вообще не включаются в бандл (достаточно перестать их использовать). Это избавляет от ручного `import`, `npm install` и отписки. Кроме того, `$mol` использует *написание логики без коллбеков/async*: асинхронность абстрагируется реактивными свойствами (поддерживается Suspense API), что упрощает код по сравнению с промисами или хуками React.

* **CRUS-DB vs Firebase (и др.):** CRUS-DB – **децентрализованная, локально-ориентированная** база данных. В отличие от Firebase (клиент-сервер, завязанного на Google), CRUS-DB работает *прямо в браузерах*: все данные читаются/пишутся локально, а затем асинхронно синхронизируются с другими пирами через WebSocket/WebRTC. При этом используется CRDT (конвергентные типы) – изменения от разных клиентов **мерджатся без конфликтов**. Это обеспечивает 100% доступность при оффлайн-режиме и отсутствие единой точки отказа. В CRUS-DB нет «обязательного сервера»: системы master/discovery опциональны; в будущем планируется чисто peer-to-peer синхронизация.

  В сравнении с Firebase, CRUS заявляет о большей скорости, лёгкости и безопасности: например, всё хранится в памяти с фоновыми дампами (WAL не требуется), а изменения подписываются криптографически (zero-trust). Таким образом, философия CRUS – *всегда локально, всегда реактивно, всегда в сети* (или *даже без сети*).

* **Другие аспекты:** В \$mol нет «скрытой магии»: все механизмы открыты и могут быть переопределены. Система имен и модулей основана на filesystem-DSL (MAM), а не на конфиг-файлах – это резко отличает \$mol от проектов с громоздкими настроечными пайплайнами. Рендеринг виртуальных деревьев в \$mol легковесен и оптимизируется автоматически, что на практике даёт очень быстрый старт и рендер (в примере: 100KB бандл, запуск под 2 с на мобильном).

## 5. Рекомендации и best practices

* **Структура проекта:** Разбивайте код на модули по функциональности. Каждый модуль – это папка с именем (namespace), в ней могут быть подмодули. Например, рекомендуемый неймспейс – ваш уникальный (не `my`). Внутри модуля `app` обычно лежит `app.view.tree` (верстка), `app.ts` (логика), `app.meta.tree` (мета-настройки, например, `include /mol/offline/install`). MAM сам создаёт `package.json` с зависимостями. **Если нужно вручную подключить npm-модуль,** можно создать `package.json` в модуле – MAM “смажет” его с автоматически сгенерированным. Файлы именуются по роли: `*.node.ts`, `*.web.ts`, `*.ts` – определяют, попадёт ли код в серверный или веб-бандл. Файлы `*.test.ts` идут в тестовые бандлы (см. ниже).

* **Кодирование и стилевое оформление:** \$mol-код пишется на TypeScript: классы компонентов наследуются от `$mol_object` или `$mol_view`, а всё поведение задаётся методами-свойствами. Предпочтительно использовать атрибуты `$mol_mem`, `$mol_action` для реактивных свойств/действий. Для стилизации применяется система `$mol_style_define`, гарантирующая типобезопасность CSS (компилятор проверит имена селекторов и вложенности). Для отступов/цветов используйте предопределённые константы `$mol_gap`, `$mol_theme` и т.п. (как в примере с `$mol_theme.card`). Не забывайте про BEM-атрибуты: `$mol` может автоматически генерировать их по методу `$mol_bem`.

* **Тестирование:** MAM имеет встроенную поддержку модульного тестирования. Файлы `*.test.ts` автоматически собираются в бандлы `web.test.js` и `node.test.js`. При запуске тестового бандла сначала загружается приложение, затем выполняются тесты. MAM сортирует тесты по глубине зависимостей, чтобы сначала тестировались нижележащие модули. Рекомендуется запускать тесты после каждой сборки (MAM сам запускает их), и «по оси» останавливать выполнение при ошибке. Используйте встроенный \$mol-тестовый фреймворк (`$mol_test`), который похож на Jest/Mocha, но тесно интегрирован с MAM.

* **Организация и расширение компонентов:** Все компоненты \$mol являются компонуемыми и настраиваемыми. Дочерние компоненты можно «перекрывать» через методы (каждый метод – свойство) и заменять в инстансах. Например, вы можете изменить шаблон `$mol_page` или добавить новые поля в свое представление без форка. Благодаря декларативности `view.tree` и отсутствию скрытых магий, расширить функциональность проще, чем в большинстве фреймворков.

* **Структура UI:** Следуйте паттерну «модель – представление – страница». `view.tree` файлы описывают DOM-разметку компонентов декларативно. Например:

  ```view.tree
  $meet_form $mol_page
    Titile
    $mol_panel
      Title
    $mol_panel
  $mol_panel
  ```

  При компиляции `view.tree` превращаются в классы TS и в итоговый HTML. Модели (как `$my_survey_meet`) подключаются через атрибуты `meet $my_survey_meet` и т.п. (см. `$mol_page` и `$mol_book2` в примере выше).

* **Работа со стилями:** В \$mol CSS описывается в TS. При помощи `$mol_style_define($Component, { ... })` вы задаёте стили для элементов компонента и его вложенных элементов (имя свойства совпадает с именем дочернего поля-компонента). Это гарантирует, что если вы ошибётесь в селекторе (нет такого компонента), TypeScript выдаст ошибку. Избегайте inline-стилей или сторонних CSS-фреймворков: весь стиль ставьте декларативно.

* **Расширение функциональности:** Для сложной функциональности можно написать свои библиотечные компоненты и опубликовать их на NPM. MAM автоматически подхватит модули при сборке. **Важно:** чтобы пакет корректно встраивался, желательно, чтобы он уже был использован в коде (т. е. в одном из `require`), иначе сборщик его просто не скачает. При разработке сторонних компонентов также оформляйте их как модули с `module-name/build/web.js` и `module-name/build/view.view.tree`.

* **Безопасность и аутентификация (CRUS):** По умолчанию доступ к данным регулируется приватными ключами пользователей. Все конфиденциальные поля в CRUS-DB шифруются «по месту» – доступ к ним есть только у владельца данных. Аутентификацию можно строить на введении пароля, который расшифрует приватный ключ из `localStorage`. Детали настройки аутентификации и синхронизации серверов лучше брать из официальной документации CRUS (например, размещая ссылки мастеров синхронизации в конфиге сервиса).

## Примечания

* *CRUS-DB:* Некоторые детали подключения CRUS (установка сервера синхронизации, управление мастерами, схемы шардинга) в данной инструкции не расписаны, так как они зависят от конкретного варианта развертывания. Изучите официальное руководство CRUS ([https://crus.hyoo.ru](https://crus.hyoo.ru)) для глубокой настройки.
* *Внешние пакеты:* Поддержка npm-пакетов в MAM/\$mol всё ещё развивается. Если вы столкнётесь с тем, что `require('some-lib')` не работает «из коробки», возможно, придётся собрать библиотеку вручную или искать аналогичную библиотеку с ESM/UMD-сборкой.
* *Ресурсы:* В качестве примеров использовались официальные источники: документация \$mol (mol.hyoo.ru), документация CRUS (crus.hyoo.ru) и репозиторий hyoo-ru/survey.hyoo.ru с пояснениями автора проекта. Если какие-то моменты вызывают вопросы, рекомендуем обратиться к исходникам этих проектов или задать вопрос в сообществе (форум h\_y\_o\_o на Telegram).
# Расширенное руководство по \$mol

## Синтаксис и паттерны view\.tree

\$mol использует декларативный язык **view\.tree** для описания интерфейсов. Здесь нет «чистого HTML» – компоненты компонуются друг в друга простыми конструкциями. Например, строка

```tree
$my_heroes $mol_view
```

создаёт новый компонент `$my_heroes`, наследующийся от базового `$mol_view`. Чтобы объявить или переопределить свойство, достаточно написать его имя с отступом и указать значение. Например:

```tree
$my_heroes $mol_view
    sub /
```

переопределяет свойство `sub` (список дочерних компонентов) как пустой список. Вложенные компоненты описываются стрелочкой `<=` и именем нового свойства. Так, в примере

```tree
$my_heroes $mol_view
    sub /
        <= Title     $mol_view
        <= Subtitle  $mol_view
        <= Rows      $mol_list
```

содержатся три дочерних компонента: `Title`, `Subtitle` (оба базового класса `$mol_view`) и `Rows` (класс `$mol_list`). Стрелка `<=` означает одностороннюю привязку: свойство слева берёт значение из компонента справа. Двусторонняя привязка обозначается `<=>` (например, `value? <=> name?`), что связывает два свойства в обоих направлениях.

Важные спецсимволы view\.tree: `/` объявляет пустой список (элемент списка располагают на новой строке с дополнительным отступом), `*` объявляет словарь из ключей, `@` – признак локализации (текст после `@` выносится в отдельный файл перевода). Чаще всего тексты в интерфейсе задают через `\` (обратная косая черта) для сырой строки без экранирования (многократный `\` – многострочный текст). Например:

```tree
<= label_text \
    \Привет, пользователь!
```

выведет строку «Привет, пользователь!» без дополнительной обработки. Если же написать `<= title @ \Hello`, то фраза «Hello» попадёт в файл локализации, а в генерируемом коде TS будет обращение `$mol_locale.text("ключ")`.

Списки и циклы реализуются через соответствующие компоненты и мультисвойства. Компонент `$mol_list` выводит список строк, заданных через свойство `rows`. Вложенный код с `Row*` и `item_content*` позволяет создавать повторяющиеся части (например, одну строку таблицы на каждую запись). В качестве «условного рендеринга» используется переопределение свойств: если в наследнике присвоить свойству `null`, этот элемент просто не отрисуется. Например:

```tree
$my_top_heroes $my_heroes
    Title_sub null
```

полностью исключает блок `Title_sub` из рендеринга. Таким образом, любые компоненты `$mol` легко настраиваются и меняются – достаточно переопределить их свойства в view\.tree.

## Пример: создание приложения с нуля

1. **Создание проекта MAM.** Самый простой способ – клонировать готовый шаблон из репозитория MAM. Выполните в терминале:

   ```bash
   git clone https://github.com/hyoo-ru/mam.git ./mam && cd mam
   npm install && npm start
   ```

   Это запустит дев-сервер MAM, который автоматически будет собирать и подавать модули при изменении файлов. Теперь ваш проект готов к разработке.

2. **Структура папок.** Создайте в корне проекта папку для вашего модуля, например `my/hello`. В ней понадобится минимум пять файлов:

   * `index.html` – точка входа в приложение.
   * `hello.view.tree` – декларативное описание компонентов.
   * `hello.view.ts` – логика компонента на TypeScript.
   * `hello.view.css` – стили компонента.
   * `hello.test.ts` – (опционально) тесты компонента.

   Например, содержимое `index.html` может быть таким:

   ```html
   <!doctype html>
   <html mol_view_root>
     <head>
       <meta charset="utf-8"/>
       <meta name="viewport" content="width=device-width, initial-scale=1"/>
       <meta name="mobile-web-app-capable" content="yes"/>
     </head>
     <body mol_view_root>
       <div mol_view_root="$my_hello"></div> <!-- Автовязка компонента -->
       <script src="web.js"></script> <!-- Автогенерируемый бандл -->
     </body>
   </html>
   ```

   Атрибут `mol_view_root="$my_hello"` в `<div>` сообщает фреймворку, что при загрузке нужно смонтировать компонент `$my_hello` в этот DOM-элемент.

3. **Наполнение view\.tree и view\.ts.** В файле `hello.view.tree` опишите интерфейс компонента. Например, простой компонент с полем ввода и сообщением:

   ```tree
   $my_hello $mol_view
       sub /
           <= Name    $mol_string
                 hint  \Name
                 value? <=> name?  \
           <= message \
   ```

   Здесь мы создаём компонент `$my_hello`, наследуемый от `$mol_view`, с двумя вложенными элементами: строковым полем `$mol_string` (с подсказкой «Name»), связанное с реактивным свойством `name?`, и полем вывода `message`. Двусторонняя привязка `value? <=> name?` обеспечивает, что при вводе в поле свойство `name()` в TS-классе обновится автоматически.

   В файле `hello.view.ts` реализуйте логику поведения, расширив автоматически сгенерированный класс:

   ```typescript
   namespace $.$$ {
     export class $my_hello extends $.$my_hello {
       @ $mol_mem
       message() {
         const name = this.name();
         return name ? `Hello, ${name}!` : '';
       }
     }
   }
   ```

   Здесь метод `message()` возвращает приветствие на основе введённого имени. Декоратор `@$mol_mem` (необязательно) кэширует результат. При изменении `name()` значение `message()` будет автоматически пересчитано. Генерируемый код TS показывает связь со свойствами view\.tree.

4. **Тестирование и стили.** Вы можете добавить тесты в `hello.test.ts` с помощью `$mol_test`, чтобы проверить поведение компонента. Пример простого теста:

   ```typescript
   namespace $.$$ {
     $mol_test({
       'Generates greeting': function() {
         const app = new $my_hello;
         $mol_assert_equal(app.message(), '');
         app.name('Jin');
         $mol_assert_equal(app.message(), 'Hello, Jin!');
       }
     });
   }
   ```

   Стили. Для оформления создайте файл hello.view.css.ts, используя типизированный подход MAM-style. Пример стилей (используются BEM-атрибуты и CSS-переменные темы):

   ```typescript
   namespace $.$$ {
     $mol_style_define($my_hello, {
       display: 'flex',
       flexDirection: 'column',
       alignItems: 'center',
       font: '1.5rem/1 sans-serif',
       boxShadow: `0 0 0 1px var(--mol_theme_line)`,
       padding: '1rem',
     })

     $mol_style_define($my_hello_name, {
       margin: '0.5rem',
       width: '200px',
     })
   }
   ```

5. **Запуск и отладка.** После сохранения файлов откройте в браузере адрес `http://localhost:9080/my/hello/`. MAM-сервер автоматически соберёт ваш модуль в `web.js` и отобразит приложение. При изменении файлов страницу нужно лишь обновить – MAM оперативно пересоберёт бандл. Отладка удобна благодаря исходным картам и читаемым идентификаторам компонентов.

## Встроенные компоненты и виджеты

\$mol предоставляет **богатую библиотеку готовых виджетов**. К наиболее часто используемым относятся:

* **Кнопки (`$mol_button`).** Базовый компонент кнопки. Существуют варианты `$mol_button_major` и `$mol_button_minor` для разных стилей. Пример в `view.tree`:

  ```tree
  <= Submit $mol_button_major
      click? <=> submit?
      sub /
        <= label @ \Submit
  ```

  Здесь при клике на кнопку срабатывает свойство `select?` (наследуемое от `$mol_button`), связанное с внешним реактивным свойством `submit?`. Вложенный элемент `label` даёт текст кнопки (с локализацией). CSS-темы `$mol_theme` управляют основными цветами кнопки (например, CSS-переменная `--mol_theme_control` используется по умолчанию).

* **Поля ввода (`$mol_string`, `$mol_number`, `$mol_textarea`).** Однострочное (`$mol_string`) и многострочное (`$mol_textarea`) текстовые поля, а также числовые (`$mol_number`). У них есть свойства `value? <=> ваш_метод?` и `hint` для подсказки. Эти компоненты поддерживают валидацию и автозаполнение.

* **Формы (`$mol_form`).** Компонент для группировки полей с декларативными валидаторами. Позволяет автоматически проверять поля на клиенте и отображать ошибки. Подробнее о валидации – в документации компонентов (например, `$mol_form` содержит встроенные валидаторы).

* **Списки и страницы (\$mol\_list, \$mol\_page, \$mol\_deck).**
  – `$mol_list` – вертикальный список строк; каждый элемент – `$mol_row`. Используется, например, для отображения коллекций данных.
  – `$mol_page` – стандартная страница с шапкой, телом и подвалом. Позволяет задать `title`, `body` и т.д.
  – `$mol_deck` – «колода» панелей с панелью вкладок. Это механизм переключения между разными страницами внутри одного модуля. `$mol_deck` управляет текущим активным табом вверху панели.

* **Выпадающий список (`$mol_select`).** Компонент с выпадающим меню, поддержкой поиска и «ленивой» подгрузкой опций. Свойство `options` задаёт варианты. Например:

  ```tree
  <= CitySelect $mol_select
      options /
          \Moscow
          \New York
          \Tokyo
      value? <=> selected_city? \
  ```

  Здесь меню предзаполнено городами. Библиотека виджетов `$mol_select` автоматически добавляет поиск по опциям.

* **Таблицы (`$mol_grid`).** Компонент для виртуальных таблиц с прокруткой. Он работает со списками идентификаторов столбцов, строк и ячеек. Например, в демо-калькуляторе используется:

  ```tree
  $mol_app_calc $mol_page
      sub /
          <= Head    -
          <= Current $mol_bar
          <= Body    $mol_grid
  ```

  где `$mol_grid` – **компонент для рисования виртуальных таблиц**. Он умеет «лениво» рендерить только видимые ячейки, что выгодно при больших объёмах данных.

* **Темы и стили.** Фреймворк имеет систему тем `$mol_theme`. Через CSS-переменные и константы можно задавать оформление. Например, `$mol_theme_auto` автоматически переключает светлую/тёмную тему в зависимости от системных настроек пользователя. Цветовые токены (`$mol_theme.text`, `$mol_theme.control` и т.п.) используются в стилях компонентов. В примере кода выше в стилях мы ссылались на `var(--mol_theme_line)` для цвета контура.

* **Локализация.** Строки интерфейса можно легко локализовать: достаточно в view\.tree пометить текст ключом `@`, после чего генератор вынесет его в JSON-файл (`web.locale=en.json` и т.д.). При сборке будет сгенерирован метод TypeScript, использующий `$mol_locale.text("key")`. Это позволяет быстро переключать языки интерфейса.

Полный список виджетов и их краткое описание можно найти в документации: например, `$mol_button` – кнопка, `$mol_check` – чекбокс, `$mol_switch` – переключатель, `$mol_select` – селект с поиском, `$mol_calendar` – календарь (таблица дней), `$mol_chat` – чат на основе GitHub, `$mol_form` – формы с валидаторами и т.д. Практически любой стандартный HTML-блок или элемент представлен готовым компонентом \$mol, который можно сразу использовать или расширить под свои нужды.

## Продвинутые темы

* **Ленивая отрисовка и загрузка.** \$mol изначально рассчитан на «ленивость» во всём. Компоненты рендерятся по мере необходимости, а зависимости между ними вычисляются автоматически. Это означает, что интерфейс обновляется эффективно – при изменении одного свойства пересоздаются только зависящие от него части. Фреймворк предоставляет автоматическую оптимизацию потоков данных и поддержку асинхронных операций (Suspense) на всех уровнях.

* **Кастомизация и расширение.** Любое поведение можно изменить, переопределив соответствующее свойство в view\.tree или TS-коде. Например, для удаления блока мы присвоили свойству `null` (см. `$my_top_heroes Title_sub null`). Вы можете создавать подклассы компонентов в TS: в примере выше мы расширили `$.$my_hello`, дополнив метод `message()`. Базовые компоненты (\$mol\_view, \$mol\_page и др.) содержат множество точек расширения: их можно заменять либо наследованием в коде, либо перестраивать композицию в view\.tree.

* **Многомодульные (многостраничные) приложения.** MAM позволяет организовывать приложение из нескольких модулей. Каждый модуль – это отдельный каталог со своими компонентами. Dev-сервер MAM умеет одновременно обслуживать несколько модулей, а на бою можно собирать их порционно. Например, командой `npm start path/to/module` можно собрать только нужный модуль и получить готовые бандлы. Таким образом, фронтенд может быть разделён на логические страницы (модули) с общей кодовой базой. Для переключения страниц можно использовать компоненты `$mol_deck` (панель табов) или свои роутеры, а MAM автоматически объединит зависимости из всех модулей.

* **Переиспользование компонентов.** Любой компонент \$mol полностью самодостаточен, поэтому его легко выносить в отдельные модули или npm-пакеты. MAM автоматически обнаруживает зависимости между модулями: достаточно просто ссылаться на компонент по его полному имени. Внутри сгенерированного кода доступ к компонентам из глобального пространства (`new this.$.$mol_grid`) идёт через поле `this.$` – это механизм инверсии контроля, позволяющий встраивать свои реализации или заглушки. Например, можно переопределить глобальный контекст, чтобы один компонент использовал другую версию плагина.

* **Интеграция с другими библиотеками.** \$mol легко совмещается с внешними сервисами и модулями MAM. В экосистеме есть множество маленьких пакетов (\$mol\_db для IndexedDB, \$mol\_wire для реактивности, \$mol\_theme для работы с темами и т.д.), которые просто подключаются по именам. Благодаря тому что компоненты генерируются на TypeScript, можно использовать стандартные отладочные инструменты VSCode и любую стороннюю JS-библиотеку (например, внутри реактивных методов вы можете вызывать любые функции).

В итоге, фреймворк \$mol поддерживает принципы гибкой «модульности LEGO»: простые компоненты собираются в сложные интерфейсы, а разработчик имеет полный контроль над связями между ними. Используя официальную документацию и готовые демо с сайта mol.hyoo.ru, вы сможете быстро освоить все эти возможности и создавать производительные прогрессивные приложения.

**Источники:** Официальная документация и примеры из репозитория \$mol.
